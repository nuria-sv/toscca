% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/main.R
\name{MSCCA}
\alias{MSCCA}
\title{Sparse Canonical Correlation Analysis. Computation of CC via NIPALS with soft thresholding.}
\usage{
MSCCA(
  A,
  B,
  nonzero_a,
  nonzero_b,
  K = 1,
  alphaStart = "eigen",
  folds = 10,
  silent = FALSE,
  toPlot = TRUE,
  typeResid = "basic",
  combination = FALSE,
  parallel_logic = FALSE
)
}
\arguments{
\item{A, B}{Data matrices.}

\item{nonzero_a, nonzero_b}{Numeric. Scalar or vector over the number of nonzeroes allowed for a correlation estimate.}

\item{K}{Numeric. Number of components to be computed.}

\item{alphaStart}{Character. Type initialisation for \deqn{\mathbf{\alpha}}. Default is "eigen".}

\item{folds}{Numeric. Number of folds for the cross-validation process.}

\item{silent}{Logical. If FALSE, a progress bar will appear on the console. Default is FALSE.}

\item{toPlot}{Logical. If TRUE, plot will be generated automatically showing the estimated canonical weights. Default is TRUE.}

\item{typeResid}{Character. Choice of residualisation technique. Options are basic (default), null and LV.}

\item{combination}{Logical. If TRUE, the algorithm will search for the best combination of sparsity choice nonzero_a and nonzero_b for each component. This should be used for exploratory analysis. Default is FALSE.}

\item{parallel_logic}{Logical. If TRUE, cross-validation is done in parallel.Default is FALSE.}
}
\value{
a list with the following elements:
\itemize{
\item{alpha}{Canonical vector for matrix \deqn{\mathbf{A}}, for each combination of sparsity value specified.}
\item{beta}{Canonical vector for matrix \deqn{\mathbf{B}}, for each combination of sparsity value specified.}
\item{cancor}{Max. canonical correlation estimate.}
}
\description{
This function performs CCA on matrices \deqn{\mathbf{A}} and \deqn{\mathbf{B}} via Non-Iterative PArtial Least Squares (NIPALS) algorithm
imposing sparsity over a fixed number of variables especified.
}
\details{
For a exploratory analysis nonzero_a and nonzero_b can be vectors. The algorithm will then search for the best combination of sparsity choice nonzero_a and nonzero_b for each component.
}
